import { createSignal, children, createMemo, createComputed, untrack, batch, createEffect } from 'solid-js';

function nextFrame(fn) {
  requestAnimationFrame(() => {
    requestAnimationFrame(fn);
  });
}

const Transition = props => {
  let el;
  let first = true;
  const [s1, set1] = createSignal();
  const [s2, set2] = createSignal();
  const resolved = children(() => props.children);
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  const classnames = createMemo(() => {
    const name = props.name || "s";
    return {
      enterActiveClass: props.enterActiveClass || name + "-enter-active",
      enterClass: props.enterClass || name + "-enter",
      enterToClass: props.enterToClass || name + "-enter-to",
      exitActiveClass: props.exitActiveClass || name + "-exit-active",
      exitClass: props.exitClass || name + "-exit",
      exitToClass: props.exitToClass || name + "-exit-to"
    };
  });

  function enterTransition(el, prev) {
    if (!first || props.appear) {
      const enterClasses = classnames().enterClass.split(" ");
      const enterActiveClasses = classnames().enterActiveClass.split(" ");
      const enterToClasses = classnames().enterToClass.split(" ");
      onBeforeEnter && onBeforeEnter(el);
      el.classList.add(...enterClasses);
      el.classList.add(...enterActiveClasses);
      nextFrame(() => {
        el.classList.remove(...enterClasses);
        el.classList.add(...enterToClasses);
        onEnter && onEnter(el, () => endTransition());

        if (!onEnter || onEnter.length < 2) {
          el.addEventListener("transitionend", endTransition);
          el.addEventListener("animationend", endTransition);
        }
      });

      function endTransition(e) {
        if (el && (!e || e.target === el)) {
          el.removeEventListener("transitionend", endTransition);
          el.removeEventListener("animationend", endTransition);
          el.classList.remove(...enterActiveClasses);
          el.classList.remove(...enterToClasses);
          batch(() => {
            s1() !== el && set1(el);
            s2() === el && set2(undefined);
          });
          onAfterEnter && onAfterEnter(el);
          if (props.mode === "inout") exitTransition(el, prev);
        }
      }
    }

    prev && !props.mode ? set2(el) : set1(el);
  }

  function exitTransition(el, prev) {
    const exitClasses = classnames().exitClass.split(" ");
    const exitActiveClasses = classnames().exitActiveClass.split(" ");
    const exitToClasses = classnames().exitToClass.split(" ");
    if (!prev.parentNode) return endTransition();
    onBeforeExit && onBeforeExit(prev);
    prev.classList.add(...exitClasses);
    prev.classList.add(...exitActiveClasses);
    nextFrame(() => {
      prev.classList.remove(...exitClasses);
      prev.classList.add(...exitToClasses);
    });
    onExit && onExit(prev, () => endTransition());

    if (!onExit || onExit.length < 2) {
      prev.addEventListener("transitionend", endTransition);
      prev.addEventListener("animationend", endTransition);
    }

    function endTransition(e) {
      if (!e || e.target === prev) {
        prev.removeEventListener("transitionend", endTransition);
        prev.removeEventListener("animationend", endTransition);
        prev.classList.remove(...exitActiveClasses);
        prev.classList.remove(...exitToClasses);
        s1() === prev && set1(undefined);
        onAfterExit && onAfterExit(prev);
        if (props.mode === "outin") enterTransition(el, prev);
      }
    }
  }

  createComputed(prev => {
    el = resolved();

    while (typeof el === "function") el = el();

    return untrack(() => {
      if (el && el !== prev) {
        if (props.mode !== "outin") enterTransition(el, prev);else if (first) set1(el);
      }

      if (prev && prev !== el && props.mode !== "inout") exitTransition(el, prev);
      first = false;
      return el;
    });
  });
  return [s1, s2];
};

function getRect(element) {
  const {
    top,
    bottom,
    left,
    right,
    width,
    height
  } = element.getBoundingClientRect();
  const parentRect = element.parentNode.getBoundingClientRect();
  return {
    top: top - parentRect.top,
    bottom,
    left: left - parentRect.left,
    right,
    width,
    height
  };
}

const TransitionGroup = props => {
  const resolved = children(() => props.children);
  const classnames = createMemo(() => {
    const name = props.name || "s";
    return {
      enterActiveClass: props.enterActiveClass || name + "-enter-active",
      enterClass: props.enterClass || name + "-enter",
      enterToClass: props.enterToClass || name + "-enter-to",
      exitActiveClass: props.exitActiveClass || name + "-exit-active",
      exitClass: props.exitClass || name + "-exit",
      exitToClass: props.exitToClass || name + "-exit-to",
      moveClass: props.moveClass || name + "-move"
    };
  });
  const {
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onBeforeExit,
    onExit,
    onAfterExit
  } = props;
  const [combined, setCombined] = createSignal();
  let p = [];
  let first = true;
  createComputed(() => {
    const c = resolved();
    const comb = [...c];
    const next = new Set(c);
    const prev = new Set(p);
    const enterClasses = classnames().enterClass.split(" ");
    const enterActiveClasses = classnames().enterActiveClass.split(" ");
    const enterToClasses = classnames().enterToClass.split(" ");
    const exitClasses = classnames().exitClass.split(" ");
    const exitActiveClasses = classnames().exitActiveClass.split(" ");
    const exitToClasses = classnames().exitToClass.split(" ");

    for (let i = 0; i < c.length; i++) {
      const el = c[i];

      if (!first && !prev.has(el)) {
        onBeforeEnter && onBeforeEnter(el);
        el.classList.add(...enterClasses);
        el.classList.add(...enterActiveClasses);
        nextFrame(() => {
          el.classList.remove(...enterClasses);
          el.classList.add(...enterToClasses);
          onEnter && onEnter(el, () => endTransition());

          if (!onEnter || onEnter.length < 2) {
            el.addEventListener("transitionend", endTransition);
            el.addEventListener("animationend", endTransition);
          }
        });

        function endTransition(e) {
          if (el && (!e || e.target === el)) {
            el.removeEventListener("transitionend", endTransition);
            el.removeEventListener("animationend", endTransition);
            el.classList.remove(...enterActiveClasses);
            el.classList.remove(...enterToClasses);
            onAfterEnter && onAfterEnter(el);
          }
        }
      }
    }

    for (let i = 0; i < p.length; i++) {
      const old = p[i];

      if (!next.has(old) && old.parentNode) {
        comb.splice(i, 0, old);
        onBeforeExit && onBeforeExit(old);
        old.classList.add(...exitClasses);
        old.classList.add(...exitActiveClasses);
        nextFrame(() => {
          old.classList.remove(...exitClasses);
          old.classList.add(...exitToClasses);
        });
        onExit && onExit(old, () => endTransition());

        if (!onExit || onExit.length < 2) {
          old.addEventListener("transitionend", endTransition);
          old.addEventListener("animationend", endTransition);
        }

        function endTransition(e) {
          if (!e || e.target === old) {
            old.removeEventListener("transitionend", endTransition);
            old.removeEventListener("animationend", endTransition);
            old.classList.remove(...exitActiveClasses);
            old.classList.remove(...exitToClasses);
            onAfterExit && onAfterExit(old);
            p = p.filter(i => i !== old);
            setCombined(p);
          }
        }
      }
    }

    p = comb;
    setCombined(comb);
  });
  createEffect(nodes => {
    const c = combined();
    c.forEach(child => {
      let n;

      if (!(n = nodes.get(child))) {
        nodes.set(child, n = {
          pos: getRect(child),
          new: !first
        });
      } else if (n.new) {
        n.new = false;
        n.newPos = getRect(child);
      }

      if (n.new) {
        child.addEventListener("transitionend", () => {
          n.new = false;
          child.parentNode && (n.newPos = getRect(child));
        }, {
          once: true
        });
      }

      n.newPos && (n.pos = n.newPos);
      n.newPos = getRect(child);
    });

    if (first) {
      first = false;
      return nodes;
    }

    c.forEach(child => {
      const c = nodes.get(child);
      const oldPos = c.pos;
      const newPos = c.newPos;
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;

      if (dx || dy) {
        c.moved = true;
        const s = child.style;
        s.transform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
      }
    });
    document.body.offsetHeight;
    c.forEach(child => {
      const c = nodes.get(child);

      if (c.moved) {
        c.moved = false;
        const s = child.style;
        const moveClasses = classnames().moveClass.split(" ");
        child.classList.add(...moveClasses);
        s.transform = s.transitionDuration = "";

        function endTransition(e) {
          if (e && e.target !== child || !child.parentNode) return;

          if (!e || /transform$/.test(e.propertyName)) {
            child.removeEventListener("transitionend", endTransition);
            child.classList.remove(...moveClasses);
          }
        }

        child.addEventListener("transitionend", endTransition);
      }
    });
    return nodes;
  }, new Map());
  return combined;
};

export { Transition, TransitionGroup };
